\documentclass[a4paper,12pt, master]{etf}

\usepackage[intlimits]{amsmath}
\usepackage{amsmath, amsfonts, amssymb, graphicx}

\usepackage[serbian]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}

\addto\captionsserbian{\renewcommand{\bibname}{Literatura}}

\title{Implementacija vremenske sinhronizacije u Namenskim ra\v{c}unarskim sistemima}
\author{Lazar Caković}
\indeks{3083/2016}
\date{septembar 2018.}
\mentor{Prof. dr Lazar Saranovac}
\predmet{}

\begin{document}

	\maketitle

	\tableofcontents

	\listoffigures

	\newpage

	\chapter{Apstrakt}

	\newpage

	\chapter{Uvod}

    Sinhronizacija postaje neophodna kada su uredjaji koji rade zajedno na odredjenoj 
	udaljenosti moraju raditi u vezi jedni sa drugima. U ovim scenirijima, lokalni sat, ili 
	Master Sat, sinhronizuje sve uredjaje u istom sistemu sa tim satom. Zbog ove potrebe za 
	sinhronizacijom, IEEE 1588 standard je objavljen kao standardni protokol 2002. godine.
	(\#\#[lazarc] However, prevod \#\#) Iako su dva sata unutar uredjaja podeseni da rade na 
	istoj frekvenciji, ne postoji garancija da ce ostati sinhronizovani. Upravo zbog ovoga 
	proces sinhronizacije je neprekidan. Nekoliko faktora mogu uticati na to da dva identicna 
	sata izgube sinhronizaciju. Razlozi mogu biti razliciti, kao na primer razlika u 
	temperaturi, starosti uredjaja, kao i frekvenciji na kojoj uredjaji rade, koja moze 
	uticati na kvalitet sinhronizacije. Upravo iz ovih razloga je i nastala potreba za 
	sinhronizacijom uredjaja.
	
	\newpage

	\chapter{Protokol}

	\section{OSI model}

	Open Systems Interconnection model (OSI model) je konceptualni model koji karakterise i
	standardizuje komunikacione funkcije u telekomunikacionim ili kompjuterskim sistemima, i 
	to bez obzira na unutrasnju strukturu uredjaja ili njihovu tehnologiju. Cilj ovog modela 
	je da se postigne kompatibilnost razlicitih komunikacionih sistema sa standardnim 
	protokolima komunikacije. OSI model razdvaja komunikacione sisteme u apstraktne slojeve. 
	Originalna verzija modela ima sedam slojeva.

	Sloj unutar modela sluzi sloj iznad njega, i koristi sloj ispod njega u hijerarhiji. Na 
	primer, sloj koji postize komunikaciju preko mreze bez gresaka, sluzi aplikacijama iznad 
	koje ga koriste, i to dok poziva jednostavne funkcije za prijem i predaju paketa na mrezi. 
	Dve instance istog sloja su vizualizovane tako sto su povezane horizontalno u istom sloju.

	Ovaj model je proizvod Open Systems Interconnection projekta u International Organization 
	for Standardization (ISO), i ima oznaku ISO/IEC 7498-1.

	\#\# [lazarc] slika svih slojeva u osi modelu

	Na svakom nivou N, dva entiteta na komunikcionim uredjajima razmenjuju jedinice protokola 
	(PDU - protocol data units) pomocu sloja N protokola. Svaki PDU sadrzi podatke od interesa 
	(payload) (SDU - service data unit), zajedno sa zaglavljima koji odgovaraju protokolu.

	Obrada podataka izmedju dva uredjaja koji su OSI-kompatibilni se odvija u sledecim 
	koracima:
	\begin{itemize}
		\item Podaci koji se prenose se formiraju na najvisem sloju u uredjaju koji predaje 
		podatke na mrezi (sloj N) u jedinicu protokola (PDU).
		\item PDU se prosledjuje sloju N-1, gde je poznat kao SDU.
		\item Na sloju N-1 se na SDU dodaju zaglavlja, na osnovu cega se formira PDU za sloj 
		N-1. Nakon cega se prosledjuje na sloj N-2.
		\item Ovaj postupak se ponavlja sve dok se ne dostigne najnizi sloj u modelu, nakon 
		cega se podaci prenose ka uredjaju koji prima podatke.
		\item Na strani prijemnog uredjaja se podaci prenose od najnizeg sloja u modelu, do
		najviseg, gde se serije SDU struktura uspesno obradjuju, pri cemu se skidaju zaglavlja 
		sa svakog sloja, dok se ne dostigne najvisi sloj u modelu, nakon cega su dostupni 
		sirovi podaci.
	\end{itemize}

	\#\# [lazarc] dodati jos nesto o ovome ukoliko se nadje.

	\subsection{Sloj 1: Fizicki sloj (Physical Layer)}

	Fizicki sloj je odgovoran za prenos i prijem nestrukturiranih sirovih podataka izmedju 
	uredjaja i fizickog medijuma za prenos. On pretvara digitalne bitove u elektricne, radio 
	ili opticke signale. Specifikacije sloja definisu karakteristike poput nivoa napona, 
	fizicke brzine prenosa podataka, maksimalne udaljenosti prenosa i fizickih konektora. Ovo 
	ukljucuje raspored pinova, napona, linijske impedanse, specifikacije kablova, vremenskih 
	signala i frekvencije za bezicne uredjaje. Kontrola brzine bitova se vrsi na fizickom 
	nivou i moze definisati nacin komunikacije kao simpleks, polu dupleks ili dupleks 
	komunikaciju. Komponente fizickog sloja mogu se opisati u smislu topologije mreze. 
	Bluetooth, Ethernet i USB, sve imaju specifikacije za fizicki sloj.

	\subsection{Sloj 2: Sloj veze (Data Link Layer)}

	Sloj veze podataka obezbedjuje prenos podataka izmedju dva cvora u komunikaciji - vezu 
	izmedju dva direktno povezana uredjaja na mrezi. Ovaj sloj otkriva i eventualno ispravlja 
	greske koje se mogu javiti u fizickom sloju. On definise protokol za uspostavljanje i 
	prekid veze izmedju dva fizicki povezana uredjaja. Takodje, definise protokol za kontrolu 
	protoka izmedju njih.

	IEEE 802 standard deli sloj veze na dva podsloja:
	\begin{itemize}
		\item \textbf{Kontrola pristupa medijumu (MAC - Medium access control):}
		\#\# [lazarc] [prevod]
		odgovorna je za kontrolu nacina na koji uredjaji na mrezi dobijaju pristup medijumu i
		dozvolu za prenos podataka.
		\item \textbf{Kontrola logicke veze (LLC - Logical link control):}
		\#\# [lazarc] [prevod]
		odgovorna je za identifikaciju i enkapsulaciju slojeva mreznog protokola, i kontrolu
		gresaka i sinhronizaciju paketa koji se salju.
	\end{itemize}

	MAC i LLC slojevi IEEE 802 mreznog standarda kao sto su 802.3 Ethernet, ili 802.11 Wi-Fi su
	slojevi veze (data link layer).

	Point-to-Point Protocol (PPP) - je protokol sloja veze koji radi na nekoliko razlicitih
	fizickih slojeva, kao sto su sinhrone ili asinhrone serijske linije.

	\subsection{Sloj 3: Mrezni sloj (Network Layer)}

	Mrezni sloj obezbedjuje funkcionalno i proceduralno sredstvo prenosa sekvenci podataka
	promenljive duzine, koji se nazivaju jos i paketi, od jednog cvora do drugog, poveznih u
	"razlicite mreze". \#\# [lazarc] [prevod] \#\# Mreza je medijum na koji moze biti povezano 
	vise cvorova, u kom svaki cvor ima adresu i koji dozvoljava cvorovima povezanim sa njim da 
	prenose poruke ka ostalim cvorovima, i to samo dajuci sadrzaj poruke i adresu cvora na 
	koji poruka treba da bude dostavljena, omogucavajuci mrezi da nadje nacin da isporuci 
	poruku odredisnom cvoru, eventualno ga usmeravajuci kroz sredisnje cvorove (uredjaje koji 
	su izmedju dva uredjaja koji pokusavaju da komuniciraju). Ako je poruka prevelika da bi se 
	prenela sa jednog uredjaja na drugi samo koriscenjem sloja veze (Data Link Layer), mreza 
	moze preneti podatke tako sto ce ih podeliti u nekoliko delova na jednom uredjaju, poslati 
	delove nezavisno, i onda spojiti delove na drugom uredjaju. Pri cemu moze, iako nije uvek 
	potrebno, prijaviti greske u isporuci.

	Isporuka poruka na mreznom sloju nije garantovano pouzdana. Mrezni sloj moze pruziti 
	pouzdanu isporuku poruka, ali nije obavezno da to mora biti ispunjeno.

	Neki broj protokola koji upravljaju slojevima, imaju funkciju koja je definisana u aneksu
	upravljanja, ISO 7498/4, i pripadaju mreznom sloju. Oni ukljucuju protokole rutiranja,
	upravljanja grupomsa vise uredjaja, informacije o mreznom sloju, o greskama, kao i 
	dodeljivanje adresa mreznog sloja medju uredjajima. Ustvari, to je funkcija podataka koji 
	se prenose uz pomoc protokola, sto ih cini da pripadaju mreznom sloju, a ne protokolu. 
	\#\# [lazarc] poslednja	recenica [prevod] \#\#

	\subsection{Sloj 4: Transportni sloj (Transport Layer)}

	Transportni sloj obezbedjuje funkcionalno i proceduralno sredstvo prenosa sekvenci podataka
	promenljive duzine od predajnog do prijemnog uredjaja, uz odrzavanje kvaliteta.

	Transportni sloj kontrolise pouzdanost date konekcije kroz kontrolu protoka,
	segmentaciju/desegmentaciju i kontrolu gresaka. Neki protokli su orjentisani na stanje 
	mreze, a neki na konekciju u mrezi. \#\# [lazarc] [prevod] \#\# Ovo znaci da Transportni 
	sloj moze da prati segmente i ponovo preneti one koji nisu isporuceni prijemnom uredjaju. 
	Transportni sloj takodje omogucava i potvrdu uspesnog prenosa podataka i salje naredne 
	podatke ako nije doslo do greske prilikom prenosa. Transportni sloj formira i segmente 
	koji su primljeni iz visih slojeva, npr Aplikativnog sloja (Application Layer). 
	Segmentacija je proces podele dugih poruka u krace poruke kako bi se lakse prenele preko 
	nizih slojeva u modelu.

	OSI model definise pet klasa transportnih protokola za povezivnje od klase 0 (koja je 
	takodje poznata i kao TP0 i ima najslabije karakteristike) do klase 4 (TP4, koja je 
	dizajnirana za manje pouzdane mreze, slicne Internetu). Klasa 0 (TP0) nema mogucnost 
	oporavka od greske i bila je dizajnirana za koriscenje na mreznim slojevima koji pruzaju 
	konekciju bez gresaka. Klasa 4 (TP4) je najbliza TCP, iako TCP sadrzi neke funkcije koje 
	se u OSI modelu dodeljuju visim slojevima. Takodje, sve klase u OSI modelu omogucavaju 
	brzu upotrebu podataka i ocuvanje granica podataka \#\# [lazarc] [prevod] \#\#. Detalje 
	karakteristika svih klasa prikazane su u sledecoj tabeli:

	\#\# [lazarc] tabela sa interneta
	\#\# [lazarc] prebaci tabelu na srpski

	\subsection{Sloj 5: Sloj sesije (Session Layer)}

	Sloj sesije kontrolise dijaloge (veze) izmedju uredjaja. Uspostavlja, upravlja i uklanja 
	veze izmedju lokalnih i udaljenih aplikacija. Obezbedjuje funkcije Full-Duplex, 
	Half-Duples ili	Simplex i uspostavlja procedure Checkpoint-a, prekida ili ponovnog 
	pokretanja procedura. OSi model je ucinio ovaj sloj odgovornim za dobro zavrsavanje sesija,
	sto je osobina TCP (Transmission Control Protocol), i takodje proveru sesija i oporavak, 
	sto se obicno ne koristi u Internet Protocol Suite. Sloj sesije se obicno eksplicitno 
	primenjuje u sredinama aplikacija koje koriste proceduralne pozive na udaljenim uredjajima.

	\subsection{Sloj 6: Sloj prezentacije (Presentation Layer)}

	Sloj prezentacije uspostavlja kontekst izmedju dva entiteta aplikativnog sloja, u kom 
	entiteti aplikativnog sloja mogu koristiti razlicitu sintaksu i semantiku ukoliko sloj 
	prezentacije pruza mapiranje izmeju njih. Ukoliko je dostupno mapiranje, jedinice 
	protokola su enkapsulirane u jednice sesije i prosledjene na nize slojeve.

	Ovaj sloj obezbedjuje nezavisnost od predstavljanja podataka u razlicitim aplikacijama i
	mreznim formatima. Sloj prezentacije pretvara podatke u oblik koji prihvata zadata 
	aplikacija.	Ovaj sloj formatira podatke koji se salju preko mreze. Ponekad se naziva i 
	sintaksni sloj.	Takodje, moze ukljucivati i funkcije kompresije.

	\subsection{Sloj 7: Aplikativni sloj (Application Layer)}

	Aplikativni sloj je OSI sloj najblizi krajnjem korisniku, sto znaci da i OSI aplikativni 
	sloj i korisnik interaguju direktno sa aplikacijom. Ovaj sloj komunicira sa softverskom 
	aplikacijom	koja sadrzi komponentu za komunikaciju. Takve aplikacije ne spadaju u okvir 
	OSI modela.	Funkcije u aplikativnom sloju obicno ukljucuju identifikovanje partnera u 
	komunikaciji, odredjivanje dostupnosti resursa i sinhronizaciju komunikacije. Prilikom 
	identifikacije uredjaja za komunikaciju, aplikativni sloj se razlikuje od samih 
	aplikacija. Na primer, internet aplikacija (web strana) moze imati dva entiteta - dve 
	aplikacije: jedna koja koristi HTTP za komunikaciju sa korisnicima, i drugu za udaljenu 
	bazu podataka koja cuva podatke. Ni jedan od ovih protokola nemaju nista sa podacima koji 
	se cuvaju, to se nalazi samo u aplikaciji. Aplikacijski sloj nema nacina za odredjivanje 
	resursa u mrezi.

	\section{Internet protocol suite}
	
	Internet protocol suite (TCP/IP) je konceptualni model i set komunikacionih protokola koji se 
	koriste za Internet i slicne kompjuterske mreze. Opste je poznat kao TCP/IP zbog toga sto 
	su osnovni protokoli u ovom modelu TCP (Transmission Control Protocol) i IP (Internet 
	Protocol). Ponekad se naziva i DoD (Department of Defense) model zbog toga sto je 
	razvijanje ovog modela potpomoglo Ministarstvo odbrane SAD-a kroz DARPA.

	Internet protokol suite (\#\# [lazarc] [prevod]\#\#) omogucava razmenu podataka izmedju dva
	uredjaja na mrezi, i to specificirajuci kako ce se podaci deliti u pakete, adresirati,
	prenositi, rutirati, i primati. Ove funkcionalnosti su organizovane u cetirir apstraktna 
	sloja, koja klasifikuju sve protokole s obzirom na to u kom delu povezivanja se nalaze 
	(\#\#[lazarc] [prevod] scope of networking involved \#\#). Od najnizeg do najviseg, 
	slojevi se dele na Link	Layer (Sloj povezivanja), koji sadrzi komunikacione metode za 
	podatke koji ostaju unutar jednog segmenta mreze; Internet Layer (Sloj interneta), koji 
	omogucava povezivanje izmedju nezavisnih mreza; Transport Layer (Sloj prenosa), koji 
	omogucava komunikacione servise za aplikacije na uredjajima u mrezi; i Application Layer 
	(Sloj aplikacije), koji omogucava servise korisnicima i	sistemskim aplikacijama.

	Tehnicki sandardi koji specificiraju Internet protocol suite (\#\#[lazarc] [prevod]\#\#) i 
	mnogi od protokola koji cine IPS odrzava Internet Engineering Task Force (IETF). IPS je 
	model koji prethodi OSI modelu, koji je dosta detaljniji i opisuje vise u mreznom sistemu.

	Key architectural principles:
	Princip od kraja do kraja je evoluirao tokom vremena. Njegov prvobitni izraz je stavio 
	odrzavanje stanja i sveobuhvatne inteligencije na ivice, i pretpostavio da internet koji je 
	povezivao krajeve nije zadrzao nikakvo stanje i koncentrisao se na brzinu i jednostavnost. 
	Potrebe za zastitnim zidovima (\#\#[lazarc] firewalls \#\#), prevodiocima mreznih adresa, 
	kesiranju veb sadrzaja i slicno, su izazvale promene u ovom principu.

	Princip robusnosti kaze: "Uopsteno, implementacija mora biti konzervativna u ponasanju 
	prilikom slanja i liberalna u svom ponasanju prilikom prijema. Sto znaci, da mora biti 
	oprezna pri slanju dobro formiranih paketa (\#\#[lazarc] datagrams \#\#), ali mora 
	prihvatiti bilo koji paket koji moze protumaciti. (na primer, ne primecivati tehnicke greske 
	gde nije poznato sta ih uzrokuje.)". "Drugi deo principa je gotovo jednako vazan: softver na 
	drugim uredjajima moze sadrzati razlike koji cine nerazumnim da se iskoriste legalne, ali 
	nejasne karakteristike protokola".

	Enkapsulacija se koristi za obezbedjivanje apstrakcije protokola i usluga. Enkapsulacija je 
	obicno uskladjena sa podelom unutar protokola na slojeve funkcionalnosti. Uopsteno, 
	aplikacija (najvisi nivo modela) koristi skup protokola za slanje svojih podataka kroz 
	slojeve. Podaci se dalje enkapsuliraju na svakom sloju.

	Rani dokumenti o ovom protokolu, govore o cetvoroslojevnom protokolu. Sto je u upotrebi i 
	danas. I oni su unutar protokola korisceni u istom redosledu u kom ce i ovde biti navedeni.

	\begin{itemize}
		\item Aplikativni sloj (Application layer)
		Aplikativni sloj je opseg unutar kog aplikacije kreiraju korisnicke podatke i prenose 
		ove podatke drugim aplikacijama na istom ili drugom uredjaju (hostu). Aplikacije ili 
		procesi, koriste usluge koje pruzaju donji slojevi, posebno transportni sloj koji 
		obezbedjuje pouzdane ili nepouzdane veze ka drugim procesima. Komunikacione partnere 
		karakterise arhitektura aplikacije, kao sto su model klijent-server i umrezavanje 
		ravnopravnih korisnika. Ovo je sloj u kome su svi protokoli viseg nivoa, kao sto su SMTP,
		 FTP, SSH, HTTP, i td. Procesi se adresiraju preko portova koji u sustini predstavljaju 
		 usluge.
		\item Transportni sloj (Transport layer)
		Transportni sloj obavlja komunikacije izmedju domacina, ili domacina na istim ili 
		razlicitim uredjajima (hostovima) i na lokalnoj mrezi ili udaljenim mrezama razdvojenim 
		od rutera. Ovaj sloj obezbedjuje kanal za komunikacione potrebe aplikacija. UDP je 
		osnovni protokol transportnog sloja koji pruza nepouzdanu uslugu sa paketima. Protokol 
		za kontrolu prenosa (TCP) omogucava kontrolu protoka, uspostavljanje veze i pouzdan 
		prenos podataka.
		\item Internet sloj (Internet layer)
		Internet sloj razmenjuje pakete preko mreze. Ovaj sloj obezbedjuje uniforman mrezni 
		interfejs koji skriva stvarnu topologiju (raspored) osnovnih mreznih veza. Zbog toga se 
		naziva i slojem koji uspostavlja rad na mrezi. Zaista, ovaj sloj definise i uspostavlja 
		internet. Ovaj sloj definise strukture adresiranja i usmeravanja koje se koriste za 
		pakete TCP/IP protokola. Primarni protokol u ovom opsegu je Internet protokol, koji 
		definise IP adrese. Njegova sledeca funkcija u usmeravanju je da prenosi pakete pakete 
		na sledeci IP ruter koji ima vezu sa mrezom blize kranjem odredistu podataka.	
		\item Sloj veze (Link layer)
		Sloj veze definise metode umrezavanja u okviru lokalne mrezne veze na kojoj uredjaji 
		(hostovi) komuniciraju bez rutera u medjukomunikaciji. Ovaj sloj ukljucuje protokole 
		koji se koriste za opisivanje topologije lokalne mreze i potrebnih interfejsa da bi se 
		zavrsio prenos paketa sa Internet sloja na ostale uredjaje.
	\end{itemize}

	Slojevi protokola blizu vrha su logicno blizi korisnickoj aplikaciji, dok su oni blize dnu 
	logicki blizi fizickom prenosu podataka. Pregled slojeva u smislu pruzanja i koriscenja 
	usluge je metoda aplikacije koja izoluje gornje slojeve protokola od detalja kao sto je 
	prenos bitova, detekcije loseg prenosa, na primer, dok su nizi slojevi izolovani od detalja 
	aplikacije i principa rada aplikacije.

	\section{Precission Time Protocol}
    
	Protokol preciznog vremena (Precision Time Protocol (PTP)) je protokol
	kori\v{s}\'{c}en za sinhronizaciju satova preko kompjuterske mre\v{z}e. U lokalnoj
	kompjuterskoj mre\v{z}i (local area connection), posti\v{z}e se preciznost sata i u rangu
	ispod mikrosekunde, \v{s}to ga \v{c}ini pogodnim za merenja i kontrolne sisteme.

	PTP je originalno definisan u IEEE 1588-2002 standardu, i zvani\v{c}no nazvan
	``Standard for a Precision Clock Synchronization Protocol for Networked Measurement
	and Control Systems`` i objavljen 2002 godine. U 2008 godini, IEEE 1588-2002 je
    objavljen kao preradjen standard, poznat i kao PTP Version 2, sa pobolj\v{s}anom 
    ta\v{c}no\v{s}\'{c}u, precizno\v{s}\'{c}u i robusno\v{s}\'{c}u, medjutim nije kompatibilan 
    sa prethodnom verzijom koja je objavljena 2002 godine.

	``IEEE 1588 je dizajniran da popuni prazninu koja nije dobro obradjena ni jednim od dva
	dominantna protokola, NTP i GPS. IEEE 1588 je dizajniran za lokalne sisteme u kojima je
	potrebna preciznost izvan one koja je dostupna NTP protokolom. Takodje je dizajniran za
	aplikacije koje se ne mogu nositi sa cenom GPS prijemnika na svakom uredjaju, ili sa onima 
    u kojima nije mogu\'{c}e dobijanje GPS signala.`` (``IEEE 1588 is designed to fill a niche 
    not well served by either of the two dominant protocols, NTP and GPS. IEEE 1588 is designed 
    for local systems requiring accuracies beyond those attainable using NTP. It is also designed 
    for applications that cannot bear the cost of a GPS receiver at each node, or for which GPS 
    signals are inaccessible.`` - Eidson, John C. (April 2006). Measurement, Control and 
    Communication Using IEEE 1588. Springer. ISBN 1-84628-250-0.

    \subsection{Arhitektura}
    
	IEEE 1588 standard opisuje hijerarhijsku master-slave arhitekturu za distribuciju vremena. 
	Pod	ovom arhitekturom podrazumeva se distribucija vremena u sistemu koji se sastoji od 
	jednog ili vi\v{s}e komunikacionih medijuma (segmenata koji su povezani na mre\v{z}u), i jednog 
    ili vi\v{s}e izvora	ta\v{c}nog vremena. \#Obi\v{c}ni uredjaj\# Izvor ``obi\v{c}nog`` vremena 
    (``ordinary clock``) je uredjaj sa jednim pristupom mre\v{z}i i ima jednu od dve uloge, ili je 
    izvor (master) ta\v{c}nog vremena, ili \v{c}eka na ta\v{c}no vreme (slave) u komunikaciji na 
    mre\v{z}i. \#Sporedni uredjaj\# Grani\v{c}ni sat (Boundary	clock) ima vi\v{s}e pristupa, na 
    razli\v{c}ite mre\v{z}e, i mo\v{z}e precizno sinhronizovati jedan segment mre\v{z}e na drugi. 
    Master sinhronizacije se bira za svaki segment mre\v{z}e u sistemu. \#Glavni uredjaj\# 
    Referentno vreme koje se uzima za izvor sinhronizacionog sata se zove Grandmaster clock. 
    Grandmaster dostavlja sinhronizacione informacije do svih uredjaja koji su povezani na istu 
    mre\v{z}u sa njim. Ukoliko se u nekom delu mre\v{z}e nalazi Boundary clock on prosledjuje 
    ta\v{c}no vreme ka ostalim uredjajima koji su direktno na njega povezani.

	\# mora slika ovde kako izgleda arhitekura tacno

	Simplifikovano, PTP sistem se sastoji od Ordinary clocks \#Obicnog uredjaja\# poveznih na
	jednostavnu mre\v{z}u, i bez Boundary clocks \#Sporednih uredjaja\#. Grandmaster se bira, i svi
	ostali uredjaji se direktno sinhroni\v{s}u na njega.

	IEEE 1588-2008 predstavljaju Clock koji je povezan sa mre\v{z}nom opremom koja prenosi PTP 
	poruke.	Transparent clock \#Transparentni uredjaj\# modifikuje PTP poruke koje prolaze 
	kroz uredjaj. Vremenski pe\v{c}ati (TIMESTAMPs) u porukama su modifikovani tako da se uzme u 
	obzir i vreme za koje poruka prolazi kroz dodatne uredjaje u komunikaciji. Ova \v{s}ema 
	komunikacije povecava distribuciju preciznosti tako \v{s}to se kompenzuje promenljivost 
	dostave podataka preko mre\v{z}e.

	PTP tipi\v{c}no koristi EPOCH vreme, standardno vreme za UNIX sisteme (1 Januar 1970 kao 
    po\v{c}etak	ra\v{c}unanja vremena). Dok je UNIX vreme bazirano na Univerzalnom vremenu UTC, 
    i mora da postoji sekunda preskoka (\#Ovo dodati, mozda u uvod\#), PTP je baziran na 
	Medjunarodnom Atomskom Vremenu (TAI - International Atomic Time). PTP Grandmaster daje 
	trenutnu razliku izmedju UTC i TAI,	kako bi UTC vreme moglo da se izra\v{c}una od primljenog 
	PTP vremena.

	\# mora slika da se vidi razlika izmedju UTC i PTP, TAI

    \subsection{Detalji protokola}
    
	Sinhronizacija i obrada u PTP sistemu se posti\v{z}e razmenom poruka preko komunikacionog 
	medijuma. Do sad, PTP standard propisuje samo ove tipove poruka.

    \begin{itemize}
	    \item Sync, Follow\_Up, Delay\_Req i Delay\_Resp poruke se koriste u Ordinary i Boundary 
	    uredjajima i slu\v{z}e samo za razmenu informacija o vremenu koje se koriste za 
	    sinhronizaciju uredjaja na mre\v{z}i.
	    \item Pdelay\_Req, Pdelay\_Resp i Pdelay\_Res\_Follow\_Up se koriste u Transparent Clock 
	    uredjajima da mere ka\v{s}njenje kroz uredjaj tako da se mo\v{z}e iskoristiti u kompenzaciji 
	    vremena u sistemu. Transparent Clock i definicija ovih poruka nisu dostupne u IEEE 
	    1588-2002 standardu.
	    \item Announce poruke se koriste i Best master clock algorithm u IEEE 1588-2002 standardu za
	    algoritam odredjivanja najta\v{c}nijeg sata na mre\v{z}i, i to kako bi se izgradila hijerarhija
	    uredjaja i kako bi se odredio Grandmaster.
        \item Management poruke se koriste u upravljanju mre\v{z}om za posmatranje performansi na 
        mre\v{z}i, konfiguraciju mre\v{z}e i odr\v{z}avanje PTP sistema.
	    \item Signalne poruke se koriste u komunikaciji izmedju uredjaja koje nisu vremenski kriti\v{c}ne.
        Signalne poruke su uvedene u IEEE 1588-2002 standard.
    \end{itemize}

	Poruke se karakterizuju kao Event i General, odnosno poruke dogadjaja i opste poruke. Event
	poruke su vremenski kriti\v{c}ne i to u preciznosti predaje i prijema preciznosti vremenskih 
	pe\v{c}ata (TIMESTAMPs) i direktno uti\v{c}u na distribuciju preciznosti vremena. (JOS JEDNOM 
	POGLEDAJ OVAJ PREVOD). Sync, Delay\_Req, Pdelay\_Req i Pdelay\_resp su poruke dogadjaja. 
	Op\v{s}te poruke su ubi\v{c}ajene jedinice protokola, zato \v{s}to su podaci u ovim porukama od 
	zna\v{c}aja za PTP, ali njihovi vremenski pe\v{c}ati za predaju i prijem nisu. Announce, Follow\_Up,
	Delay\_Resp, Pdelay\_Resp\_Follow\_Up, Management i Signalne poruke su op\v{s}te poruke.

    \subsection{Prenos poruka}
    
	PTP poruke mogu da koriste UDP (User datagram portocol) preko Internet protokola (UDP/IP) 
	za prenos poruka. IEEE 1588-2002, koristi samo IPv4 prenos, ali je ovo pro\v{s}ireno da 
	uklju\v{c}uje i IPv6 u IEEE 1588-2008 standardu. U IEEE 1588-2002, sve PTP poruke se \v{s}alju u 
	Multicast (modulu objavljivanja na mre\v{z}i) (\#pogldedaj opet ovaj prevod\#), dok je u IEEE 
	1588-2008 to uvedeno kao opcija.

	\subsection{Algoritam najboljeg sata}
    BMC \(Best master clock algorithm\) algoritam obavlja deljenu selekciju najboljeg kandidata 
    za ta\v{c}no vreme prema slede\'{c}im karakteristikama:

    \begin{itemize}
        \item Identifikator: Univerzalni jednistveni identifikator za sat. Tipi\v{c}no je baziran 
        na MAC adresi uredjaja.
        \item Kvalitet: Obe verzije IEEE 1588 standarda poku\v{s}avaju da kvantifikuju kvalitet sata 
        na osnovu o\v{c}ekivanih devijacija u vremenu, tehnologije koja je kori\v{s}\'{c}ena za 
        implemntaciju vremena ili lokacije u hijerarhiji satova, u \v{s}emi kvaliteta satova 
        (clock stratum scheme).
        \item Prioritet: Administrativno dodeljen prioritetni znak koji BMC koristi kako bi \v{s}to 
        bolje odredio Grandmaster u PTP domenu. Dok je IEEE 1588-2002 standard imao samo jednu logi\v{c}ku
	    promenljivu kako bi odredio prioritet, IEEE 1588-2008 ima dva 8-bitna polja prioriteta.
        \item Varijansa: Procena stabilnosti sata zasnovana na zapa\v{z}anju njegovog u\v{c}inka prema PTP 
	    refernci.
    \end{itemize}

	IEEE 1588 koristi hijerarhijski algoritam selekcije zasnovan na slede\'{c}im osobinama, u
	nazna\v{c}enom redosledu:

    \begin{itemize}
        \item Prioritet 1: korisnik mo\v{z}e dodeliti specifi\v{c}an stati\v{c}ki dizajniran prioritet 
        svakom satu pre	svega odredjuju\'{c}i prioritet medju njima. Manje vrednosti prioriteta 
        ozna\v{c}avaju ve\'{c}i prioritet.
	    \item Klasa: Svaki sat je \v{c}lan odredjene klase, svaka klasa dobija svoj prioritet.
	    \item Preciznost: Preciznost izmedju sata i UTC, u nanosekundama.
	    \item Varijansa: Varijabilnost sata.
        \item Prioritet 2: Definisan prioritet, defini\v{s}u\'{c}i redosled rezervne kopije u slu\v{c}aju 
        da drugi kriterijumi nisu dovoljni. Manje vrednosti prioriteta ozna\v{c}avaju ve\'{c}i prioritet.
	    \item Jedinstveni identifikator: selekcija zasnovana na MAC adresi se koristi kao metod 
	    odlu\v{c}ivanja	kada su sve ostale osobine iste.
    \end{itemize}

    Svojstva sata se daju u IEEE 1588-2002 standardu porukama za sinhronizaciju (Sync messages) i u 
    IEEE 1588-2008 standardu u porukama za ogla\v{s}avanje (Announce messages). Trenutni Master clock (\#\#
	[lazarc] [prevod]\#\#) prenosi sve informacije u rednovnim intervalima. Sat koji sebe 
	smatra boljim od trenutnog Master sata prenosi\'{c}e ove informacije kako bi se pozvali svi 
	uredjaji za pormenu	Master sata. Kada trenutni Master prepozna bolji sat, tada Master sat 
	zaustavlja emitovanje poruka za sinhronizaciju (Sync Messages), ili poruke ogra\v{s}avanja 
	(Announce messages), u zavisnosti od verzije protokola, i bolji sat preuzima ulogu Master 
	sata. BMC algoritam uzima u obzir samo osobine koje su ve\'{c} poznate, i koje su deklarisali 
	sami satovi, i ne uzima u obzir	kvalitet veze na mre\v{z}i.

	\subsection{Sinhronizacija}

	Koriste\'{c}i BMC algoritam, PTP bira Master sat za IEEE 1588 domen i za svaki segment mre\v{z}e 
    unutar tog domena. Satovi odredjuju razliku izmedju njih (offset) i Master-a na mre\v{z}i. Neka 
    promenjiva $t$ predstavlja fizi\v{c}ki vreme. Za dati Slave uredjaj, razlika $o(t)$ u vremenu $t$ 
    se defini\v{s}e kao:

    \begin{equation}
        o(t) = s(t) - m(t)
    \end{equation}

	gde $s(t)$ predstavlja vreme mereno satom na Slave uredjaju u vremenu $t$, dok $m(t)$
	predstavlja vreme mereno satom na Master uredjaju u vremenu $t$.

	Master uredjaj periodi\v{c}no objavljuje (Broadcasts) trenutno vreme kao poruku ostalim 
	uredjajima na mre\v{z}i. IEEE 1588-2002 protokolom je definisana objava vremena na svaku 
	sekundu. Dok je IEEE 1588-2008 protokolom dozvoljeno i do 10 objava vremena u jednoj 
	sekundi.

	\#\# [lazarc] [slika] sync

    Svaka objava vremena kre\'{c}e u vremenskom trenutku $T_1$, i to Sync porukom koju \v{s}alje 
    Master uredjaj svim uredjajima u domenu. Uredjaj koji prima ovu poruku pamti vreme $T_1'$ u 
    kom je primio Sync poruku. Master mo\v{z}e naknadno poslati Follow\_up poruku u kojoj \'{c}e 
    se nalaziti ta\v{c}no vreme $T_1$ u kom je poslata prethodna poruka. Nemaju svi Master uredjaji 
    sposobnost da po\v{s}alju ta\v{c}ne vremenske oznake unutar Sync poruke. Tek nakon \v{s}to je 
    prenos zavr\v{s}en, oni mogu dobaviti ta\v{c}ne vremenske trenutke stizanja Sync poruke iz 
    hardvera za povezivanje na mre\v{z}u. Master uredjaji sa ovim ograni\v{c}enjima \v{s}alju 
    Follow\_up poruke kako bi preneli vreme $T_1$. Master uredjaji koji poseduju PTP mogu\'{c}nosti 
    unutar hardvera za povezivanje mogu ubaciti ta\v{c}ne vremenske oznake unutar Sync poruka, i 
    ne moraju koristiti Follow\_up poruke.

	Kako bi se ta\v{c}no sinhronizovali na Master uredjaj, satovi moraju individualno odrediti 
	vreme prenosa poruka kroz medijum za povezivanje. Vreme progresije poruke kroz medijum za 
	povezivanje	se radi merenjem vremena koje je potrebno da poruka ode od svakog uredjaja do 
	njihovog Mastera u domenu, i da se vrati nazad. Ovu razmenu iniciraju Slave uredjaji i pri 
    tome mere vreme	progresije poruke $d$. Razmena poruka po\v{c}inje tako \v{s}to Slave uredjaj 
    \v{s}alje Delay\_Req poruku u vremenskom trenutku $T_2$ ka svom Master uredjaju. Master uredjaj 
	primi ovu poruku, i kao	odgovor po\v{s}alje ta\v{c}nu vremensku oznaku kada je primio Delay\_Req 
	poruku. Poruka odgovora	Delay\_Resp sadrzi ta\v{c}no vreme $T_2'$ u kome je primljena poruka 
	Delay\_Req.

	Nakon razmene ovih poruka Slave uredjaj ima spoznaju o \v{c}etiri vremenska trenutka $T_1$, 
	$T_1'$,	$T_2$ i $T_2'$.

	Ukoliko je $d$ vreme koje je potrebno Sync poruci da prodje kroz medijum za povezivanje, a 
    $\tilde{o}$	konstantna razlika satova izmedju Master i Slave uredjaja, onda je:
    
	\begin{equation}
		T_1' - T_1 = \tilde{o} + d
	\end{equation}

	i

	\begin{equation}
			T_2' - T_2 = -\tilde{o} + d
	\end{equation}

	Odakle je:

	\begin{equation}
		\tilde{o} = \frac{1}{2} (T_1' - T_1 - T_2' + T_2)
	\end{equation}

	Sada dva uredjaja znaju koliki je ofset $\tilde{o}$ prilikom prenosa i mogu se ispraviti 
	tako da budu u skladu sa Master uredjajem.

	Jedna pretpostavka je da se prenos poruka odvija u periodu vremena koji je tako mali, da se
	razlika moze smatrati konstantnom u tom periodu. Jos jedna pretpostavka je da je vreme 
	koje je	potrebno da poruka stigne od Master do Slave uredjaja ista kao i u obrnutom smeru. 
	I na kraju,	pretpostavka je da i Master i Slave uredjaji mogu da precizno mere vremenske 
    trenutke u kojima \v{s}alju ili primaju poruke. Stepen primene ovih pretpostavki uti\v{c}e 
    na to koliko \'{c}e se dobro sinhronizovati dva uredjaja.

    \#\# [lazarc] Pogledaj jos da se ubaci sa Teams za Valeo
    
	\newpage

	\chapter{Operativni sistem}

	\section{FreeRTOS}

	FreeRTOS je kernel operativnog sistema koji radi u realnom vremenu, i to za namenske 
	sisteme, i moze se koristiti na preko 35 mikrokontrolera.

	(Wiki) Implementacija:
	FreeRTOS je dizajniran tako da bude mali i jednostavan. Kernel (srce operativnog sistema) 
	se sastoji od samo 3 fajla, i pisan je u C programskom jeziku. Kako bi se kod napravi da 
	bude citljiv, lako portabilan, i kako bi se lako odrzavao projekat, pisan je uglavnom u C
	programskom jeziku, sa izuzetkom da su neke funkcionalnosti napisane u asembleru, gde je to
	bilo potrebno, i to uglavnom rutine u Scheduler-u (Rasporedjivacu??? \#\#[lazarc] [prevod]
	\#\#) koje su specificne za samu arhitekturu.

	FreeRTOS omogucava koriscenje metoda za stvaranje vise programskih niti, ili Taskova, 
	stvaranje mehanizama za Sinhronizaciju niti, Mutexa, Semafora i softverskih tajmera. 
	Takodje, postoje mogucnosti koriscenja FreeRTOS-a i za aplikacije niske potrosnje. 
	Aplikacije koje se koriste FreeRTOS mogu biti kompletno staticki alocirane. Alternativno 
	RTOS objekti mogu dinamicki	alocirane sa 5 sema alokacije memorije i one cine:
	
	\begin{itemize}
		\item samo alocirati;
		\item alocirati i osloboditi sa jednostavnim, brzim algoritmom;
		\item kompleksnija ali brza alokacija i oslobadjanje uz algoritam spajanja sussednih
		memorijskih blokova;
		\item alternativa za jos kompleksiniju semu koja ukljucuje spajanje susednih 
		memorijskih	blokova	koja omogucava da hip (HEAP) bude podeljen na vise memorijskih 
		delova;
		\item i na kraju C biblioteka za alociranje i oslobadjanje sa zastitom medjusobnog 
		iskljucivanja.
	\end{itemize}

	Unutar FreeRTOS-a ne postoji ni jedan od slozenijih svojstava operativnih sistema koji se
	uobicajeno mogu naci u operativnim sistemima poputi Linux-a ili Microsoft Windows-a, kao 
	sto su drajveru uredjaja, napredno upravljanje memorijom, korisnicki nalozi, i 
	umrezavanje. Akcenat ovog operativnog sistema je na kompaktnosti i brzini izvrsavanja. O 
	FreeRTOS-u se moze misliti kao o "biblioteci niti" vise nego kao o "operativnom sistemu". 
	(\#\# [lazarc] , although command line interface and POSIX-like I/O abstraction add-ons 
	are available \#\#)

	FreeRTOS implementira vise niti tako sto postoji jedan program koji poziva metode niti u
	jednakim kratkim vremenskim intervalima. Metoda promene niti zavisi od prioriteta niti i
	ukljucuje round-robin semu promene niti. Uobicajen interval promene je do 1/1000 sekunde do
	1/100 sekunde, i to kroz prekid hardverskog tajmera, ali interval promene se cesto menja 
	tako da zadovolji potrebe specificne aplikacije.

	FreeRTOS Documentation:
	FreeRTOS je idealno sklopljen za duboke namenske aplikacije u realnom vremenu koje koriste
	mikrokontrolere ili male mikroprocesore. Ovaj nacin projektovanja aplikacija ukljucuje
	kombinaciju kako strogih zahteva za realnim vremenom u aplikaciji, tako i manje strogih.

	Strogi zahtevi za aplikacijama realnog vremena su oni u kojima postoji vremenski rok u
	izvrsavanju, i ako se taj rok probije, doci ce do apsolutnog pada funkcionalnosti sistema. 
	Na primer, airbag u kolima ima potencijal da napravi vise stete nego dobrog ukoliko je 
	odziv sistema samo malo sporiji nego sto treba.

	FreeRTOS je kernel realnog vrmena (ili rasporedjivac(\#\#[lazarc] [prevod]\#\#) realnog 
	vremena) na	koji se nadogradjuje aplikacija tako da ispuni stroge zahteve za realnim 
	vremenom aplikacije. To dozvoljava da aplikacija bude organizovana kao kolekcija 
	nezavisnih programskih niti. Na	procesoru koji ima samo jedno jezgro, samo jedna 
	programska nit se moze izvrsavati u jednom trenutku. Kernel odlucuje koja nit se izvrsava 
	tako sto odredjuje prioritet koji se dodeljuje svakoj niti. U najjednostavnijem slucaju, 
	dizajner aplikacije moze odrediti vise prioritete nitima koje implementiraju stroge 
	zahteve za realnim vremenom, a nize prioritete onim nitima koje nemaju tako stroge zahteve 
	za izvrsavanjem. Ovim bi se osiguralo da niti koje imaju strozije zahteve, imaju 
	prioritete izvrsavanja i pristupa resursima nad ostalim nitima, ali odluke za dodelu 
	izvrsavanja nisu uvek tako jednostavne.

	Napomena: Unutar FreeRTOS-a se programska nit naziva "task". Tako da ce se u daljem tekstu 
	i koristiti naziv Task za programsku nit.

	U projektovanju aplikacija za namenske sistema postoji ustaljena praksa projektovanja
	aplikacija koja ne zahteva koriscenje kernela za realno vreme, i ove tehnike mogu dati 
	bolje resenje problema. Mada, u kompleksnijim slucajevima, verovatnije je koriscenje 
	kernela za aplikacije u realnom vremenu, i takodje moze biti kombinacija koriscenja 
	kernela, i drugih tehnika projektovanja aplikacije.

	Kao sto je vec opisani, prioriteti taskova mogu pomoci da se osigura da aplikacija ispuni 
	sve	zahteve, ali kernel moze doneti i neke manje ocigledne beneficije. Neke od njih su 
	navedene ispod:
	
	\begin{itemize}
		\item \textbf{Skracivanje informacija o vremenskom rasporedu (Abstracting away timing 
		information):} Kernel je odgovoran za vreme izvrsavanja i dodeljuje API kojim se 
		unutar aplikacije moze upravljati vremenom. Ovim se omogucava jednostavnija 
		strukturiranost koda, i ukupna velicina koda je manja.
		\item \textbf{Odrzavanje/Prosirivanje (Maintainability/Extensibility):}
		Uskracivanjem informacija o vremenskom rasporedu rezultuje u manjim zavisnostima 
		izmedju	modula, i dozvoljava aplikaciji da evoluira u kontrolisanom i predvidjenom 
		nacinu. Takodje, kernel je odgovoran za rasporedjivanje vremena, tako da performanse 
		aplikacije manje mogu biti promenjene u hardveru na kome se pokrecu.
		\item \textbf{Modularnost (Modularity):}
		Taskovi su nezavisni moduli, pri cemu svaki od njih mora imati dobro definisanu svrhu.
		\item \textbf{Timski razvoj (Team development):}
		Taskovi bi trebalo da imaju dobro definisane interfejse, kako bi se lakse razvijali u
		timovima.
		\item \textbf{Lakse testiranje (Easier testing):}
		Ako su takskovi dobro definisani kao nezavisni moduli sa cistim interfejsima, mogu biti
		testirani nezavnisno.
		\item \textbf{Ponovno koriscenje koda (Code reuse):}
		Veca modularnost sa vecom nezavisnoscu koda koji se moze ponovo koristiti sa manje 
		ulozenog truda.
		\item \textbf{Poboljsana efikasnost (Improved efficiency):}
		Koriscenjem kernela softver se u popunosti moze prebaciti na opkretanje dogadjajima 
		(event driven programming), i time bi se ustedelo procesorsko vreme koje se trosi na 
		poliranje dogadjaja koji se ne dogadjaju. Kod se pokrece samo ukoliko postoji nesto 
		sto je potrebno	uraditi.

		Protiv poboljsane efikasnosti stoji to da je potrebno pocesuirati RTOS prekid, i 
		promeniti izvrsavanje sa jednog taska na drugi. Kako god, i aplikacije koje ne koriste 
		RTOS normalno ukljucuju neku formu prekida.
		\item \textbf{Idle time (\#\#[lazarc] [prevod]\#\#):}
		Idle task je task koji se automatski kreira prilikom startovanja Rasporedjivaca
		(\#\#[lazarc] [prevod]\#\#). I izvrsava se kad nema taskova unutar aplikacije koji bi 
		se izvrsavali. Ovaj task se moze koristiti za merenje procesorske moci koja se trosi, 
		za izvrsavanje provera u pozadini, ili da jednostavno pokrene rezim smanjene potrosnje 
		u sistemu.
		\item \textbf{Upravljanje snagom (Power management):}
		Efikasnost koja se dobija koriscenjem RTOS-a dozovoljava procesoru da provede vise 
		vremena	u rezimu smanjenje potrosnje. Potrosnja se moze znacajno smanjiti time sto 
		procesor odlazi u rezim smanjenje potrosnje kad god je pokrenut Idle task. FreeRTOS 
		takodje ima i specijalni tick-less mod, u kome procesor odlazi u rezim smanjene 
		potrosnje na duze.
		\item \textbf{Fleksibilno upravljanje prekidima (Flexible interrupt handling):}
		Upravljanje prekidima se moze drzati veoma kratko tako sto se odlaze obrada bilo kog 
		taska koji je kreirao sam dizajner, ili taska unutar FreeRTOS-a.
		\item \textbf{Razliciti zahtevi za obradom (Mixed processing requirements):}
		Jednostavni oblici dizajniranja programa mogu se postici mesanjem periodicnog, 
		kontinualnog i procesiranja pokretanog dogadjajima. Pored toga, ispunjavanje strogih i 
		manje strogih zahteva za realnim vremenom u aplikacijama moze se postici izborom 
		odgovoarajucih taskova i prioriteta prekida.

	\end{itemize}

	\section{lwIP}

	lwIP (light-weight IP) je implementacija TCP/IP komplet-a (\#\# [lazarc] [prevod] suite 
	\#\#) je originalno napisao Adam Dunkels u Computer and Networks Architectures (CNA) 
	laboratoriji na	SHvetskom institutu za kompjuterske nauke (Swedish Institute of Computer 
	Science) ali ga sad	aktivno razvija tim inzenjera sirom sveta kojim rukovodi Kieran 
	Mansley.

	lwIP je open-source projekat koji je besplatan za preuzimanje i koriscenje (pod BSD 
	licencom), pisan u C programskom jeziku i moze se preuzeti sa internet stranice tima koji 
	ga razvija.

	Fokus lwIP implementacije TCP/IP je da se smanji koriscenje RAM memorije i da se i dalje 
	dobija potpuna funcionalnost TCP. Ovim lwIP postaje interesantan za koriscenje u namenskim 
	sistemima koji raspolazu sa RAM memorijom od nekoliko desetina kilobajta kB i prostorom od 
	oko 40 kilobajta u ROM memoriji.

	Od kada je prvi put objavljen, lwIP izaziva dosta interesovanja, i danas se koristi u dosta
	komercijalnih projekata. lwIP je do sad iskoriscen na mnogim platformama i operativnim
	sistemima, i moze se koristiti bez i sa operativnim sistemom. U ovoj implementaciji, lwIP 
	se koristi u okviru FreeRTOS operativnog sistema, kao jedan njegov deo.

	LwIP je veoma modularan i ima podrsku za dosta protokola, od kojih vecina moze da se 
	ukloni za manju velicinu koda.
	\begin{itemize}
		\item \textit{Mrezni protokoli i protokoli veze: (Link and network protocols)}
		\begin{itemize}
			\item \textbf{ARP}: protokol veze koji se koristi za prevod prirodne hardver adrese
			("MAC adresa") u IP adresu
			\item \textbf{IPv4}: dominantni mrezni protkol koji se koristi danas, posebno za
			Internet
			\item \textbf{IPv6}: naslednik IPv4, koji, narocito, prosiruje velicinu IP adrese 
			na 128 bita
			\item \textbf{ICMP}: kontrolni protokol za IP
			\item \textbf{IGMP}: protokol za urpravljanje grupa unutar IP-a
		\end{itemize}
		\item \textit{Transportni protokoli: (Transport protocols)}
			\begin{itemize}
				\item \textbf{UDP}: protokol bez prikljucka, i bez mehanizma pouzdanosti
				\item \textbf{TCP}: protokol orjentisan ka konekciji, za kontinualni tok 
				podataka ("streaming")
			\end{itemize}
		\item \textit{Protokoli visokog nivoa: (High-level protocols)}
			\begin{itemize}
				\item \textbf{DHCP}: dobijanje IP adrese sa podrskom servera
				\item \textbf{AUTOIP}: dobijanje IP adrese bez podrske servera
				\item \textbf{SNMP}: koriscen za nadgledanje stanja mreze
				\item \textbf{PPP}: koriscen za stvaranje direktne konekcije izmedju dva cvora 
				na mrezi
			\end{itemize}
	\end{itemize}

	IPv4: (\#\#[lazarc] opisati u delu za softversku implementaciju \#\#)

	lwIP pruza tri API-a (Application Program's Interface) za programe koji komuniciraju sa 
	TCP/IP kodom:
	\begin{itemize}
		\item low-level "core"/"callback" ili "raw" API
		\item dva API-a viseg nivoa (sekvencijalni API-i):
			\begin{itemize}
				\item netconn API
				\item socket API
			\end{itemize}
	\end{itemize}

	Sekvencijalni API pruza nacin za obicno, sekvencijalno programiranje koje koristi lwIP stek
	(\#\#[lazarc] stack \#\#). Model izvrsavanja je baziran na blokirajucoj
	otvori-procitaj-upisi-zatvori paradigmi. Kako je TCP/IP stek baziran na dogadjajima, 
	TCP/IP kod i aplikativni program, moraju da se pozivaju sa razlicitim kontekstima 
	izvrsavanja, u razlicitim nitima.

	Prilikom mesanja sekvencijalnog i "sirovog" API-a u programima, treba biti pazljiv. 
	Funkcije koje pripadaju nesekvencijalnom API-u u stvari mogu biti pozvane iz glavne 
	tcpip\_thread niti.
	Takodje, registrovanje programski rutina (ili inicijalizovanje delova u lwIP) mora biti
	odradjeno unutar tog konteksta (na primer, u vreme startovanja aplikacije u 
	tcpip\_init\_callback rutini ili u vreme izvrsavanja unutar tcpip\_callback rutine).

	Jos neke cinjenice o API-ima koje uticu na koriscenje lwIP steka:
	\begin{itemize}
		\item \textbf{netconn- i raw-API su samo unutar lwIP-a :} kod koji koristi ovaj API se 
		ne moze koristiti u drugim stekovima koji imaju iste mogucnosti kao lwIP (na primer 
		uIP i td.)
		\item \textbf{socket API} je u suprotnosti sa gore navedenom stavkom, napravljen je 
		tako da je kompatibilan i moze se koristiti u drugim stekovima.
		\item \textbf{socket- i netconn-API} su sekvencijalni API-i koji zahtevaju programske 
		niti (jedna nit je za aplikaciju koja koristi API, jedna nit upravlja tajmerima unutar 
		steka, paketima koji dolaze, i td.)
		\item \textbf{raw API} koristi mehanizam povratnih rutina (na primer. aplikacija poziva
		rutinu kada dodje novi podatak). Ukoliko se koristi u programu koji radi na 
		sekvencijalni nacin, moze biti teze koriscenje.
		\item \textbf{raw API} daje bolje performanse kako ne zahteva promenu izvrsavanja
		programskih niti.
		\item \textbf{raw API i netconn API} podrzavaju zero-copy \footnote{predstavlja 
		operaciju pri kojoj procesor ne vrsi kopiranje podataka iz jedne memorijske oblasti u 
		drugu. Ovo se cesto koristi kako bi se sacuvali ciklusi procesora i propusnog opsega 
		memorije prilikom prenosa kontinualnih podataka (datoteka, fajlova) preko mreze.} kako 
		za TX tako i za RX.	(kako za predaju, tako i za prijem)
	\end{itemize}

	\newpage

	\chapter{Hardverska implementacija}

	Razvojno okru\v{z}enje koje je kori\v{s}\'{c}eno za hardversku implementaciju je razvojna 
	plo\v{c}a SAMA5D27-SOM1-EK1 proizvodja\v{c}a Microchip. Na plo\v{c}i se nalazi SAMA5D27 
	SOM (System on Module) modul koji je klju\v{c}an za implementaciju. Na modulu se nalazi 
	SAMA5D27-D1G-CU SIP (System in Package) koji sadr\v{z}i 1 Gbit DDR2 SDRAM memorije. Modul 
	nudi puzdanu i niskobud\v{z}etnu platformu	za razvoj namenskih ra\v{c}unarskih sistema 
	koji ce na kraju i zavr\v{s}iti u finalnoj proizvodnji, kao i malu formu, dopunjenu sa 
	velikim brojem interfejsa koji se mogu koristiti u delu projektovanja krajnjeg sistema.

	\begin{figure}[htb]
		\centering
		\includegraphics[scale=.7]{../pic/hw_top_view.png}
		\caption{Razvojna plo\v{c}a SAMA5D27-SOM1-EK1 (pogled odozgo)}
		\label{fig:hw_top_view}
	\end{figure}

	SOM je potpuno opremljen industrijski sertifikovan kompjuter dizajniran za integraciju
	korisni\v{c}ke aplikacije. SOM modul je namenski napravljen kao mala hardverska platforma
	opremljena \v{s}irokim spektrom modula za brzo povezivanje kako bi podr\v{z}ali	
	projektovanje podr\v{s}ke za razne IoT (Internet of Things) aplikacije, prenosnih uredjaja, 
	ali i aplikacija u industrijske svrhe. SOM integri\v{s}e 1Gbit DDR2 SDRAM i QSPI memoriju 
	kao 10/100 Mbit Ethernet interfejs. Takodje, SOM poseduje i 128 GPIO pinova  
	koji obezbedjuju pristup SOM-a za razli\v{c}ite upotrebe. Svi GPIO pinovi su nezavisni, i 
	mogu se konfigurisati kao ulazi	ili izlazi, sa ili bez PULL-UP otpornika. Razvojna plo\v{c}a 
	poseduje  i \v{s}irok spektar periferija, kao i korisni\v{c}ki interfejs i na\v{c}in za 
	pro\v{s}irenje funkcionalnosti, uklju\v{c}uju\'{c}i i dva microBUS Click interfejsa firme 
	Mikroelektronika kojim se dobija mogu\'{c}nost za pro\v{s}irenje funkcionalnosti svim 
	modulima koje ova firma nudi u svom asortimanu.

	\begin{figure}[htb]
		\centering
		\includegraphics[scale=.7]{../pic/hw_modules.png}
		\caption{Moduli - Razvojna plo\v{c}a SAMA5D27-SOM1-EK1}
		\label{fig:hw_modules}
	\end{figure}

	Na samom SAMA5D27-SOM1 postoje i:
	\begin{itemize}
		\item Ultra mali SIP (SAMA5D27-D1G-CU) koji sadr\v{z}i \v{s}tedljivi SAMA5D27 Arm Cortex 
		A5 procesor i 1Gbit DDR2 SDRAM memoriju
		\item SST26VF064 64 Mb QSPI Flash memoriju
		\item 24AA02E48 2 Kb serijski E2PROM (Electrically Erased Programmed Read Only Memory) 
		sa programiranom EUI identifikacijom pristupa
		\item MIC2800 cip za kontrolu napajanja
		\item KSZ8081RNA Ethernet Phy 10/100 MHz RMII
	\end{itemize}

	\begin{figure}[htb]
		\centering
		\includegraphics[scale=.7]{../pic/hw_som_modules.PNG}
		\caption{Moduli - SAMA5D27-SOM1}
		\label{fig:hw_som_modules}
	\end{figure}

	Razvojno okru\v{z}enje SAMA5D27-SOM1-EK1 je veoma mo\'{c}no i mo\v{z}e se koristiti za \v{s}
	irok spektar aplikacija. Naj\v{c}e\v{s}\'{c}e je izbor za razvoj aplikativnog softvera u 
	namenskim ra\v{c}unarskim sistemima, uz kori\v{s}\'{c}enje Embedded Linux operativnog 
	sistema, i s tim ciljem se i bira. Za ovu implementaciju nije kori\v{s}\'{c}en u tom smislu, 
	ve\'{c} je kori\v{s}\'{c}en sa drugim operativnim sistemom kojim je mogu\'{c}e ista\'{c}i 
	neke druge njegove karakteristike. Ali ono sto je najvi\v{s}e interesantno za ovu primenu je 
	postojanje TSU (Timestamping unit) za harversku podr\v{s}ku PTP-a. I to u sklopu periferije 
	za povezivanje preko Ethernet-a, cime je omogu\'{c}eno prepoznavanje PTP poruka koje dolaze 
	na interfejs.

	\section{Time stamping unit - TSU}
	IEEE-1588 je standard za preciznu sinhronizaciju vremena u lokalnim mre\v{z}ama. Radi se o 
	razmeni	preciznog vremena izmedju dva uredjaja u lokalnoj mre\v{z}i. PTP poruke se mogu 
	prenositi preko	IEEE802.3/Ethernet, IPv4 ili IPv6 protokola kako je to ve\'{c} opisano u 
	odeljcima pre. Periferija unutar razvojnog okru\v{z}enja GMAC ozna\v{c}ava ta\v{c}ku 
	vremenske oznake poruke (na po\v{c}etku slanja i na kraju slanja) poruke. IEEE 802.1AS je 
	podskup IEEE 1588 standarda. Jedina razlika je u adresi koja slu\v{z}i za slanje PTP poruka 
	svim uredjajima u lokalnoj mrezi (Multicast). GMAC periferija je dizajnirana tako da 
	prepoznaje poruke koje su klju\v{c}ne za PTP protokol. Kao \v{s}to je ve\'{c} navedeno, 
	sinhronizacija izmedju dva uredjaja se izvodi u dva stadijuma, odredjivanje razlike	(offset) 
	izmedju dva sata (na strani Master i Slave uredjaja), nakon \v{c}ega se \v{s}alje ta\v{c}no	
	ka\v{s}njenje na linijama za prenos podataka, \v{c}ime se ta\v{c}no sinhronizuju dva sata. 
	Hardverski moduli koji poma\v{z}u u ovoj razmeni poruka odredjuju ta\v{c}no vreme kada je 
	poruka stigla, i kada je poruka poslata. \v{S}to je klju\v{c}no za odredjivanje vremena 
	kojim se izra\v{c}unavaju razlika i ka\v{s}njenje. Pojava ovih poruka uzrokuje 
	prijavljivanje hardverskih prekida, tako da je mogu\'{c}e operisati sa vremenima koja se 
	dobijaju tako da se dobija fina sinhronizacija vremena dva uredjaja. Podr\v{s}ka ovom 
	protokolu u hardveru se ogleda u postojanju TSU(Timestamping unit) periferije 
	koja se sastoji od tajmera i registara u koje se sme\v{s}taju tacna vremena u trenucima kada 
	stignu ili odu poruke koje su klju\v{c}ne za dobijanje ta\v{c}nog vremena. Prekid se 
	prijavljuje kada se ovi	registri osve\v{z}e vremenom slanja ili primanja poruke bitne za PTP 
	protokol. Tajmer je implemntiran kao 94-bitni broja\v{c}, u kome vi\v{s}ih 48 bita broje 
	sekunde, narednih 30 bita nanosekunde, i preostalih 16 bita broje vreme ispod nanosekunda. 
	Ni\v{z}ih 46 bita se prevrte (roll-over) kad se izbroji ta\v{c}no jedna sekunda. Takodje, 
	prijavljuje se hardverski prekid nakon sto se izbroji jedna sekunda. Vrednosti tajmera, kao 
	i parametri za njegovo (\#\#[lazarc] CHECK! \#\#) koji je glavni takt unutar procesora, i njime 
	se takodje moze manipulisati. Promene pode\v{s}avanja tajmera unutar TSU su od velike 
	va\v{z}nosti za ta\v{c}nu sinhronizuju dva uredjaja. Ova periferija najvi\v{s}e uti\v{c}e na 
	ta\v{c}no vreme koje je potrebno sinhronizovati, i takodje daje informacije o ta\v{c}nom 
	vremenu na uredjaju koji se koristi. Vi\v{s}e detalja o samoj implemntaciji i 
	kori\v{s}\'{c}enju ove periferije bi\'{c}e dato u delu softverske implementacije.

	\newpage

	\chapter{Softverska implementacija}

	\newpage

	\chapter{Zaključak}

	\newpage

	\chapter{CHECK}
    
	\textbf{IZ PTP\_NEXT\_1.TXT}

	IEEE 1588 Unplugged – An introduction to IEEE 1588
	
	SYNOPSIS
	Sinhronizacija postaje neophodna kada su uredjaji koji rade zajedno na odredjenoj 
	udaljenosti moraju raditi u vezi jedni sa drugima. U ovim scenirijima, lokalni sat, ili 
	Master Sat, sinhronizuje sve uredjaje u istom sistemu sa tim satom. Zbog ove potrebe za 
	sinhronizacijom, IEEE 1588 standard je objavljen kao standardni protokol 2002. godine.
	(\#\#[lazarc] However, prevod \#\#) Iako su dva sata unutar uredjaja podeseni da rade na 
	istoj frekvenciji, ne postoji garancija da ce ostati sinhronizovani. Upravo zbog ovoga 
	proces sinhronizacije je neprekidan. Nekoliko faktora mogu uticati na to da dva identicna 
	sata izgube sinhronizaciju. Razlozi mogu biti razliciti, kao na primer razlika u 
	temperaturi, starosti uredjaja, kao i frekvenciji na kojoj uredjaji rade, koja moze 
	uticati na kvalitet sinhronizacije. Upravo iz ovih razloga je i nastala potreba za 
	sinhronizacijom uredjaja.
	
	SYNCHRONIZATION
	IEEE 1588 obezbedjuje sinhronizaciju dva sata u istoj mrezi koja je otporna na greske. 
	Takodje, koristi se veoma mali opseg frekvencija, procesna moc, ali i podesavanje samog 
	protokola. (\#\#[lazarc] There is very little bandwidth consumption, processing power, and 
	setup.\#\#) IEEE 1588 standard postize sve ovo koristeci protokol preciznog vremena (\#\#
	[lazarc] Precision time protocol.\#\#), ili PTP. Vremenski protokol koji se koristi 
	sinhronizuje dva sata na mrezi podesavajuci satove ka "najkvalitetnijem" satu. IEEE 1588 
	definise ospege vrednosti za standardan set karakteristika satova. Algoritam najboljeg 
	sata, BMC algorithm, odlucuje koji sat na mrezi je "najkvalitetniji", odnosno koji sat na 
	mrezi je najtacniji, i najbolji kako bi se ostali uredjaji sinhronizovali na njega. BMC 
	algoritam onda sinhronizuje sve ostale satove (slave clocks) sa ovim satom na mrezi. 
	Ukoliko se BMC (Best Master Clock) ukloni iz mreze, ili BMC algoritam odluci da taj sat 
	nije vise najtacniji, algoritam redefinise novi "najkvalitetniji" sat, i prilagodi 
	vremena ostalih satova u skladu sa tim. Nije potrebno da se administrator mreze ukljucuje 
	u bilo kom trenutku kako bi se promenio najbolji sat u mrezi, zbog toga sto je ovaj 
	algoritam otporan na greske.
	
	U ovu svrhu koristi se Bidirekciona multikast komunikacija (\#\#[lazarc] Bidirectional 
	Multicast Communication \#\#) od strane slave uredjaja kako bi se sinhronizovali na 
	najbolji sat, IEEE 1588 grandmaster clock. "Sync", Sinhronizacioni paket sadrzi vremenski 
	zig od najboljeg sata, koji predstavlja tacno vreme kada je paket poslat sa grandmaster 
	clock-a. "Follow up", Prateci paket takodje moze biti poslat sa grandmaster sata, koji 
	sadrzi vremenski zig "Sync" (sinhronizacionog) paketa. Ovakav princip razmene podataka 
	omogucava tacan vremenski zig sinhronizacionog paketa koji je prosledjen sa grandmaster 
	sata. Takodje, postoje slucajevi u kojima se ne otkriva tacno vreme slanja paketa, zbog 
	odredjenih smetnji na mrezi. Ovo je omoguceno kroz Collision detection i Random Back-off 
	mehanizama na Ethernet\/IP komunikaciji. Samo onda kad je paket kompletno poslat, nemoguce 
	je promeniti sadrzaj paketa. 
	
	Grandmaster i Slave satovi na mrezi razmenjuju "Sync", Sihnronizacione pakete sa jedne na 
	drugu strane, i postavljaju vremenske zigove pri prijemu paketa. Kombinijuci razliku u 
	satova, kao i kasnjenje na mrezi, razlika izmedju slanja i prijema sinhronizacionih 
	paketa moze biti izracunata. Koristeci razliku koja je izracunata u ovom slucaju, sat 
	moze biti podesen sa novim vrednostima, i time se moze smanjiti razlika izmedju Master i 
	Slave satova u ovoj mrezi. Razlika izmedju master i slave sinhrozniacionih paketa, i 
	obrnuto, implicira da IEEE 1588 standard radi pod pretpostavkom da je propagacija paketa 
	po mrezi simetricna. To je zbog prepostavke da slave uredjaj moze da odredi i podesi 
	kasnjenje prilikom propagacije paketa po mrezi. Kako bi se kasnjenje na mrezi odredilo, 
	slave kreira "delay request", zahtev za odredjivanjem kasnjenje, i postavlja vremenski 
	zig prilikom slanja paketa. Master sat onda postavlja vremenski zig prilikom pristizanja 
	tog zahteva, i vraca ga ka Slave uredjaju, i to u obliku "delay response" paketa, 
	odgovora za kasnjenjem. Nakon toga, odredjuje se kasnjenje po linijama na mrezi, i 
	izracunava se iz ovih paketa koji se razmenjuju.
	
	Slanje i primanje sinhronizacionih paketa dozvoljava da Slave uredjaji tacno izmere 
	razliku izmedju lokalnog\/Slave sata, i Master sata. Standardne metode podesavanja sata na 
	uredjajima nije opisano prema IEEE 1588 standardu; samo omogucava standardni protokol za 
	razmenu poruka izmedju uredjaja. Poenta ovoga je da se uredjaji i satovi razlicitih 
	proizvodjaca mogu sinhronizovati izmedju sebe.
	
	QUALITY OF SYNCHRONIZATION
	Postoje nekoliko faktora koji mogu uticati na egzaktnost sinhronizacije izmedju dva 
	uredjaja unutar IEEE 1588 mreze. Promene frekvencije na uredjaju koji daje tacno vreme, 
	koje se moze desiti izmedju dva sinhronizaciona paketa "Sync", mogu uzrokovati da se 
	izgubi sinhronizacija sa ostalim uredjajima u istom sistemu. Kako bi se predupredila 
	svaka mogucnost za gubljenje sinhronizacije, (\#\#[lazarc] High stability \#\#) mogu se 
	koristiti uredjaji sa veoma velikom stabilnoscu, kao i da se skrati vreme izmedju razmene 
	sinhronizacionih paketa. Kako bi se jos vise unapredila sinhronizacija, mogu se koristiti 
	druge vrste oscilatora u uredjajima, narocito Temperature Controlled Crystal Oscillators 
	(TXCOs) i Oven Controlled Crystal Oscillators (OCXOs). Rezulucija sata moze uticati na 
	preciznost vremenskih zigova unutar sinhronizacionih paketa. Dziter (\#\#[lazarc] Jitter 
	\#\#) iz susednih uredjaja u mrezi, kao sto su habovi i svicevi (\#\#[lazarc] hubs and 
	switches \#\#), takodje mogu uticati na preciznost sinhronizacije. Kvalitet IEEE 1588 
	mreznog sistema i kako je podesen moze takodje uticati na kvalitet sinhronizacije. Kako bi 
	se podesi sistem sa sto boljom sinhronizacijom, mora se napraviti kompromis izmedju 
	egzaktnosti sinhronizacije, cene, kao i razdaljine izmedju uredjaja u sistemu. Za sporije 
	dogadjaje unutar sistema koji ne zavise od vremena, standardna NTP sinhronizacija preko 
	interneta, koja daje sinhronizaciju na nivou milisekunde, zadovoljava sve potrebe. IEEE 
	1588 je i dalje izvanredna alternativa za sisteme koji zahteva sinronizaciju na nivou ispod 
	mikroseunde.
	
	NETWORK HIERARCHIES
	IEEE 1588 sporedni satovi (\#\#[lazarc] boundary clocks\#\#), koji se takodje i nazivaju 
	transparentni svicevi (\#\#[lazarc] transparent switches \#\#), pruzaju efektivan nacin za 
	smanjenje dzitera (\#\#[lazarc] jitter \#\#) unutar mreznog sistema baziranog na IEEE 1588 
	standardu. Svic (\#\#[lazarc] switch \#\#), koji se koristi kao sporedni sat (\#\#[lazarc] 
	boundary clock \#\#), pokrece PTP protokol i sinhronizuje se na master sat (\#\#[lazarc] 
	master clock \#\#). Sporedni sat (\#\#[lazarc] boundary clock \#\#), u navratima (\#\#
	[lazarc] in turns \#\#) preuzima ulogu master sata za sve slejvove unutar iste mreze. 
	Koristeci ovo podesavanje mreze, sva interna kasnjenja i dziter mogu biti kompenzovani i ne 
	uticu na egzaktnost sinhronizacije.
	
	Delay\_Resp, Delay\_Req, Follow\_up i Sync poruke se ne prenose kroz sporedne satove. 
	Sporedni sat se ponasa kao obican sat u smislu sinhronizacije i koristi algoritam 
	najboljeg sata unutar podmreze. Unutar podmreze koja se posmatra, ovaj uredjaj je slejv. 
	Ovo ce uticati na to da se svi ostali uredjaji koji se povezuju na sporedni sat 
	sinhronisu svoje vreme prema njemu. Hijerarhija Roditelj-Dete (\#\#[lazarc] Parent-Child 
	hierarchy \#\#) na master-slejv sate je odredjena prema sporednim satovima. (\#\#[lazarc] 
	If cyclic path occur in the network hierarchy, the best master clock algorithm lowers the 
	logical hierarchy to an acyclic graph.\#\#)	Naravno, postoji alternativa za sporedne sate, 
	i to je koriscenje transparentnih sviceva (\#\#[lazarc] switches \#\#). Transparentni svic 
	se ne ponasa kao PTP cvor unutar IEEE 1588 sistema. Umesto toga, transparetni svic podesava 
	vremenski deo PTP paketa kako bi se kompenzovalo kasnjenje koje unosi svic. Transparetni 
	svic nakon toga preracunava koliko je vremena sinhronizacioni 'Sync' paket proveo unutar 
	svica, i modifikuje vremenski zig unutar sledeceg 'Follow\_up' paketa kako bi se 
	nadoknadilo kasnjenje. PTP cvorovi mogu raditi kao da su deo veceg podsistema lokalne mreze
	i to kao da su povezani habovima (\#\#[lazarc] Hubs \#\#) koristeci transparentne sviceve.
	
	USES FOR IEEE 1588
	Precizna sinhronizacija se moze iskoristiti u sledecim aplikacijama:
	\begin{itemize}
		\item Telekomunikacije
		\item Energetska postrojenja
		\item Industrijska automacija
		\item Testiranje i merenja
		\item Robotska kontrola
	\end{itemize}

	\textbf{IZ PTP\_NEXT\_2.TXT}

	NETWORK TIMING TECHNOLOGY: NTP vs. PTP
	Vremenska sinhrnozacija igra fundamentalnu ulogu u svakoj mrezi, ali je ipak najcesce 
	dodata kao naknadna funkcionalnost. Ipak, moze znaciti razliku izmedju egzaktnog 
	odredjivanja gresaka unutar sistema, u tacnim vremenskim trenucima, i nepostojanje ideje 
	zasto se server ponasa onako kako nije predvidjeno. (\#\#[lazarc] Time synchronization 
	serves a fundamental role in any network, but it's too often added as an afterthought. 
	However, it can mean the difference between correctly troubleshooting a conflict in 
	minutes and having no idea why the server is figuratively on fire. \#\#) Za finansijske i 
	naucne institucije, vremenska sinhronizacija mora biti tacna na milijarditi, ili nekad na 
	trilioniti deo sekunde, medjutim sve vise komercijalnih i industrijskih organizacija se 
	sve vise zalazu za ideju da preciznost vremenske sinhronizacije bude u sub-milisecond 
	opsegu.
	Zasto nije dovoljno da samo sinhronizujemo svoje uredjaje preko javno dostupnog NTP 
	protokola. Nazalost, kasnjenje postoji svugde, i prosto je nemoguce postici savrsenu 
	sinhrnoizaciju. Brzina svetlosti je brza, u vakumu, foton moze napraviti krug oko zemlje 
	vise od 7 puta u sekundi, iako putuje aproksimativno 31\% sporije kroz obicnu opticku 
	mrezu, lako se moze preneti jedan bit informacije preko pola sveta za manje od desetine 
	sekunde.
	Ali, svi znamo da idealan svet ne postoji. Dodati sviceve (\#\#[lazarc] switches \#\#), 
	rutere, i ostalu mreznu infrastrukturu, i ta desetina sekunde se uveca nekoliko puta. Bez 
	specijalizovane opreme, nasa mreza lako moze dodati kasnjenje cak i vece od sekunde.
	Jos veca briga je sinhronizacija razlicitih uredjaja unutar iste mreze. Scenario u kom 
	finansijska institucija koja ima tacno 100 deonica kompanije X na berzi. U nekom trenutku 
	se pojavi informacija koja se tice kompanije X, i finansijska institucija odluci da proda 
	tih 100 akcija ne samo jednom investitoru, vec nekoliko njih u razmaku od sekunde. Ali 
	posto su serveri ove institucije nesihronizovani jedan na drugi, ne postoji uopste ideja 
	kako odrediti koja je ponuda stigla prva. U ovom realnom scenariju sinhronizacija 
	uredjaja unutar mreze je od vitalnog znacaja.

	NETWORK TIME PROTOCOL
	NTP, ili Network Time Protocol, je siroko prihvacen kao sredstvo za cuvanje vremena na 
	mrezi, i trenutno je u upotrebi cetvrta verzija samog protokola. Hijerarhijski sistem ima 
	razlicite slojeve koji se nazivaju STRATA (\#\#[lazarc] strata eng. \#\#). Statum 0 
	uredjaji su u samom vrhu i ukljucuju atomske satove, kao one koji se nalaze u GNSS 
	satelitima.	Stratum 1, ili primarni vremenski server, svaki od njih ima jedan na jedan 
	direktnu konekciju sa Stratum 1 satom, i postizu sinhronizaciju red mikrosekunde sa Stratum 
	0 satovima, i povezuju se na ostale Stratum 1 severe za brzu proveru satova i cuvanje 
	podataka. Stratum 2 serveri se mogu povezivati na vise primarnih vremenskih servera kako 
	bi se postigla veci level sinhronizacije i poboljsala preciznost, i tako dalje. NTP 
	podrzava maksimum od 15 strata uredjaja, ali svaki strata uredjaj unosi malu gresku u 
	sinhronizaciji sa Stratum 0 uredjajima.

	64-bitni vremenski zig je trenutno implementiran kako bi se podelio u dva 32-bitna dela. 
	\begin{itemize}
		\item Prva polovina broji broj sekundi do nesto preko 136 godina.
		\item Druga polovina predstavlja deo sekunde do razmere pikosekunde
	\end{itemize}

	Predlozena je promena na 128-o bitne vremenske zigove u NTPv4 protokolu, i trebalo bi da 
	poveca vremensku razmeru na nesto manje od 600 milijardi godina, pri cemu bi vremenska 
	rezolucija bila manja od femtosekunde.

	PRECISION TIME PROTOCOL
	PTP, ili Precision time protokol, je jos jedan standard za sinhronizaciju vremena preko 
	mreze, ali umesto sinhronizacije reda velicine milisekunde, PTP mreze mogu da postignu 
	sinhronizaciju reda velicine nanosekunde, ili cak pikosekunde. Za vecinu komercijalnih i 
	industrijskih aplikacija, NTP je vise nego precizan, ali ukoliko je potrebna tacnija 
	sinhronizacija i tacnije obelezavanje vremena, potrebno je migrirati sistem na PTP.

	Zbog cega je PTP toliko tacan? Koristi obelezavanje paketa hardverskim vremenskim 
	zigovima, umesto softverskih, i kao svaki fini naucni instrument, PTP oprema je 
	specijalizovana za samo jednu specijalizovanu svrhu: ocuvanje sinhronizacije izmedju 
	uredjaja. Samo iz ovih razloga, PTP mreze imaju mnogo tacniju vremensku rezoluciju, i ne 
	kao NTP uredjaji, PTP uredjaji ce ustvari ukljuciti vreme koje svaka od sinhronizacionih 
	poruka provede u svakom od uredjaja, sto ukljucuje i kasnjenje u uredjaju.

	Svaka od PTP razmena ukljucuje seriju od 4 poruke koje se razmenjuju izmedju master-a i 
	slave-a:
	\begin{itemize}
		\item Inicijalna sinhronizaciona poruka od mastera ka slejvu {Sync message}
		\item Poruka koja prati sinhronizacionu poruku od mastera ka slejvu {Follow\_up message}
		\item Poruka sa zahtevom za odredjivanje kasnjenja od slejva ka masteru {Delay\_Req 
		message}
		\item Finalni odgovor sa kasnjenjem od mastera ka slejvu {Delay\_Resp message}
	\end{itemize}
	Ova razmena pruza cetiri razlicita vremena:
	\begin{itemize}
		\item T1 -> vreme kad master posalje inicijalnu sinhronizacionu poruku
		\item T2 -> vreme kad slejv dobije inicijalnu sinhronizacionu poruku
		\item T3 -> vreme kad slejv posalje poruku sa zahtevom za kasnjenjem
		\item T4 -> vreme kad master dobije zahtev za kasnjenjem
	\end{itemize}
	Master salje sva 4 vremenska ziga ka slejvu tokom faze odgovora na zahtev za kasnjenjem, 
	i slejv moze sa tim vremenima da izracuna kasnjenje po mrezi izmedju mastera i slejva u 
	oba smera. Imajuci specijalizovani hardver koji moze da uhvati vremena lokalnog sata, 
	slejv uredjaji mogu izbeci dodatno kasnjenje koje je uslovljeno lokalnim operativnim 
	sistemom.

	NTP mreze imaju dodatno kasnjenje i manju preciznost jednostavno zbog toga sto su 
	softverski bazirane, i svi zahtevi za vremenima moraju da cekaju na lokalni operativni 
	sistem. Za vecinu kompanija, NTP pruza dovoljno tacnu rezoluciju vrmena kako bi se resili 
	svi konflikti u dogledno vrmene, dok neke organizacije zahtevaju dosta veci nivo 
	sinhronizacije.

	WHY BOTHER WITH A TIME SERVER AT ALL?
	Timestamping and client synchronization is vital for your network, but some network 
	engineers still feel like they can get away with simply syncing their servers to a public 
	internet clock. While perfectly fine for consumer devices like smartphones, internet 
	clocks are poorly suited for business networks for one simple reason: security.

	To connect your server to an internet clock requires you to first open up port 123 on 
	your firewall. Will something horrible happen as a result? We don't know, but we don't 
	know in the same way that we don't know if a burglar will break in because you left the 
	front door unlocked on your home. Why take the chance? A dedicated NTP server keeps your 
	network secure while providing more accurate timestamping.

	WHAT HAPPENS IF MY TIME SERVER IS DISCONNECTED?
	No network is perfect, and all you can hope to do is minimize downtime instead of 
	eliminating it. If your NTP or PTP time server is unable to connect to a GPS satellite or 
	other input for whatever reason, you can rest assured that it will continue to 
	synchronize your devices and maintain accurate timestamping.

	For example, our NTP100-GPS NTP server has a holdover stability of 3 seconds per year, 
	meaning that your server will still be synchronized to within 3 seconds of UTC after an 
	entire year in the dark. The high-stability model with an oven-controlled crystal 
	oscillator boasts even greater holdover stability of 250 milliseconds per year — that's 
	less than 1 millisecond per day. Our HSO-3 oscillator option, which is only available on 
	our GMR5000 NTP Server and PTP Grandmaster, further reduces drift to a maximum of 1 
	millisecond per year. 

	\newpage

\end{document}
